/* This file was generated by Ragel. Your edits will be lost.
 *
 * This is a state machine implementation of String#unpack.
 *
 * vim: filetype=cpp
 */
#include "vm/config.h"

#include "vm.hpp"
#include "object_utils.hpp"
#include "on_stack.hpp"

#include "builtin/array.hpp"
#include "builtin/exception.hpp"
#include "builtin/float.hpp"
#include "builtin/string.hpp"

namespace rubinius {

  namespace unpack {
    uint16_t swap16(uint16_t x) {
      return ((((x)&0xff)<<8) | (((x)>>8)&0xff));
    }

    uint32_t swap32(uint32_t x) {
      return ((((x)&0xff)<<24)
             |(((x)>>24)&0xff)
             |(((x)&0x0000ff00)<<8)
             |(((x)&0x00ff0000)>>8));
    }

    uint64_t swap64(uint64_t x) {
      return ((((x)&0x00000000000000ffLL)<<56)
             |(((x)&0xff00000000000000LL)>>56)
             |(((x)&0x000000000000ff00LL)<<40)
             |(((x)&0x00ff000000000000LL)>>40)
             |(((x)&0x0000000000ff0000LL)<<24)
             |(((x)&0x0000ff0000000000LL)>>24)
             |(((x)&0x00000000ff000000LL)<<8)
             |(((x)&0x000000ff00000000LL)>>8));
    }

    float swap_float(const uint8_t* str) {
      uint32_t x;
      float y;

      memcpy(&x, str, sizeof(uint32_t));
      x = swap32(x);
      memcpy(&y, &x, sizeof(float));

      return y;
    }

    double swap_double(const uint8_t* str) {
      uint64_t x;
      double y;

      memcpy(&x, str, sizeof(uint64_t));
      x = swap64(x);
      memcpy(&y, &x, sizeof(double));

      return y;
    }
  }

#define UNPACK_ELEMENTS(create, bits)                     \
  for(; index < stop; count--, index += width) {          \
    const uint8_t* bytes = self->byte_address() + index;  \
    array->append(state, create(bits(bytes)));            \
  }

#define unpack_elements   UNPACK_ELEMENTS

#define unpack_float_elements(t)  unpack_elements(to_float, t)

#define FIXNUM(b)         (Fixnum::from(b))
#define INTEGER(b)        (Integer::from(state, b))

#define to_float(b)       (Float::create(state, b))

#define SBYTE(p)          (*(int8_t*)(p))
#define UBYTE(p)          (*(uint8_t*)(p))

#define S16BITS(p)        (*(int16_t*)(p))
#define U16BITS(p)        (*(uint16_t*)(p))

#define S32BITS(p)        (*(int32_t*)(p))
#define U32BITS(p)        (*(uint32_t*)(p))

#define S64BITS(p)        (*(int64_t*)(p))
#define U64BITS(p)        (*(uint64_t*)(p))

#define float_bits(p)     (*(float*)(p))
#define double_bits(p)    (*(double*)(p))

#ifdef RBX_LITTLE_ENDIAN
# define LE_S16BITS(p)     (S16BITS(p))
# define LE_U16BITS(p)     (U16BITS(p))
# define LE_S32BITS(p)     (S32BITS(p))
# define LE_U32BITS(p)     (U32BITS(p))
# define LE_S64BITS(p)     (S64BITS(p))
# define LE_U64BITS(p)     (U64BITS(p))

# define BE_S16BITS(p)     ((int16_t)(unpack::swap16(U16BITS(p))))
# define BE_U16BITS(p)     ((uint16_t)(unpack::swap16(U16BITS(p))))
# define BE_S32BITS(p)     ((int32_t)(unpack::swap32(U32BITS(p))))
# define BE_U32BITS(p)     ((uint32_t)(unpack::swap32(U32BITS(p))))
# define BE_S64BITS(p)     ((int64_t)(unpack::swap64(U64BITS(p))))
# define BE_U64BITS(p)     ((uint64_t)(unpack::swap64(U64BITS(p))))

# define unpack_double            unpack_double_le
# define unpack_float             unpack_float_le

# define unpack_double_le         unpack_float_elements(double_bits)
# define unpack_float_le          unpack_float_elements(float_bits)

# define unpack_double_be         unpack_float_elements(unpack::swap_double)
# define unpack_float_be          unpack_float_elements(unpack::swap_float)
#else
# define LE_S16BITS(p)     ((int16_t)(unpack::swap16(U16BITS(p))))
# define LE_U16BITS(p)     ((uint16_t)(unpack::swap16(U16BITS(p))))
# define LE_S32BITS(p)     ((int32_t)(unpack::swap32(U32BITS(p))))
# define LE_U32BITS(p)     ((uint32_t)(unpack::swap32(U32BITS(p))))
# define LE_S64BITS(p)     ((int64_t)(unpack::swap64(U64BITS(p))))
# define LE_U64BITS(p)     ((uint64_t)(unpack::swap64(U64BITS(p))))

# define BE_S16BITS(p)     (S16BITS(p))
# define BE_U16BITS(p)     (U16BITS(p))
# define BE_S32BITS(p)     (S32BITS(p))
# define BE_U32BITS(p)     (U32BITS(p))
# define BE_S64BITS(p)     (S64BITS(p))
# define BE_U64BITS(p)     (U64BITS(p))

# define unpack_double            unpack_double_be
# define unpack_float             unpack_float_be

# define unpack_double_le         unpack_float_elements(unpack::swap_double)
# define unpack_float_le          unpack_float_elements(unpack::swap_float)

# define unpack_double_be         unpack_float_elements(double_bits)
# define unpack_float_be          unpack_float_elements(float_bits)
#endif

  Array* String::unpack(STATE, String* directives) {
    // Ragel-specific variables
    std::string d(directives->c_str(), directives->size());
    const char *p  = d.c_str();
    const char *pe = p + d.size();

    const char *eof = pe;
    int cs;

    // pack-specific variables
    String* self = this;
    Array* array = Array::create(state, 0);
    OnStack<2> sv(state, self, array);
    const char* bytes = 0;

    size_t bytes_size = self->size();
    size_t index = 0;
    size_t stop = 0;
    size_t width = 0;
    int count = 0;
    bool rest = false;
    bool platform = false;

%%{
  machine unpack;

  include "unpack.rl";

}%%

    if(unpack_first_final && unpack_error && unpack_en_main) {
      // do nothing
    }

    return force_as<Array>(Primitives::failure());
  }
}
