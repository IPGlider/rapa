/* This file was generated by Ragel. Your edits will be lost.
 *
 * This is a state machine implementation of String#unpack.
 *
 * vim: filetype=cpp
 */

#include "vm.hpp"
#include "object_utils.hpp"
#include "vm/config.h"

#include "builtin/array.hpp"
#include "builtin/exception.hpp"
#include "builtin/string.hpp"

namespace rubinius {

#define UNPACK_ELEMENTS(format, bits)                   \
  for(; index < stop; count--, index += width) {        \
    array->append(state, format(bits(bytes + index)));  \
  }

#define FIXNUM(b)         (Fixnum::from(b))
#define INTEGER(b)        (Integer::from(state, b))

#define BYTE(p, n, m)     ((*(((uint8_t*)(p))+n)) << (m*8))

#define SBYTE(p)          ((int8_t)BYTE(p, 0, 0))
#define UBYTE(p)          ((uint8_t)BYTE(p, 0, 0))

#define LE_16BITS(p)      (BYTE(p, 0, 0) | BYTE(p, 1, 1))
#define LE_S16BITS(p)     ((int16_t)LE_16BITS(p))
#define LE_U16BITS(p)     ((uint16_t)LE_16BITS(p))

#define BE_16BITS(p)      (BYTE(p, 0, 1) | BYTE(p, 1, 0))
#define BE_S16BITS(p)     ((int16_t)BE_16BITS(p))
#define BE_U16BITS(p)     ((uint16_t)BE_16BITS(p))

#ifdef RBX_LITTLE_ENDIAN
# define S16BITS           LE_S16BITS
# define U16BITS           LE_U16BITS
#else
# define S16BITS           BE_S16BITS
# define U16BITS           BE_U16BITS
#endif

  Array* String::unpack(STATE, String* directives) {
    // Ragel-specific variables
    const char *p  = directives->c_str();
    const char *pe = p + directives->size();
    const char *eof = pe;
    int cs;

    // pack-specific variables
    uint8_t* bytes = byte_address();
    size_t index = 0;
    size_t stop = 0;
    size_t width = 0;
    int count = 0;
    bool rest = false;
    bool platform = false;
    Array* array = Array::create(state, 0);

%%{
  machine unpack;

  include "unpack.rl";

}%%

    if(unpack_first_final && unpack_error && unpack_en_main) {
      // do nothing
    }

    return force_as<Array>(Primitives::failure());
  }
}
